{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1>R e p o r t</h1>

    <a href="{{ path('report') }}#kmom01">kmom01</a>

    <div id="kmom01">
        <p>Här är min redovisningstext för kmom01: ramverk</p>

        <p>
            Jag har tidigare läst kursen 'Algoritmer och datastrukturer med objektorienterad Python' där jag bland annat fick lära mig att angripa ett problem på ett objektorienterat sätt samt designprinciper för att utveckla objektoerienterade program.
            Den kursen uppfattade jag personligen som avancerad.
        </p>

        <p>
            PHPs modell för klasser och objekt använder sig av objektorienterad programmering.
            Grunderna man behöver ha koll på för att kunna komma igång och skapa sina första klasser är:
            1. Konstruktor; Den används för att initilaisera objektets egenskaper när man skapar det. 
            Konstruktorn körs automatiskt när objektet skapas och den kan ta emot argument som parametrar vilka den använder för att sätta egenskaper.
            2. Egenskaper; Beskriver objektets tillstånd. Egenskaper representerar data som är unik för varje objekt och kan, som ovan nämnt, tilldelas värden från konstruktorn och/eller från objektets metoder.
            3. Metoder; Beskriver hur ett objekt beter sig. Metoder kan användas för att ändra på objektets egenskaper eller utföra andra saker som behövs för objektet, likt funktioner.
            4. Arv; Betyder att en klass kan ärva egenskaper och metoder från en annan klass. Detta gör att man, baserat på en grundklass, kan skapa mer specialiserade klasser.
        </p>

        <p>
            Strukturen som används till uppgiften me/report kan till en början bli väldigt överväldigande.
            Med tiden ser man dock att man oftast enbart jobbar i mapparna assets, public, src och templates.
            Nu i början är koden fortfarande lite svår, men jag hänger med ganska bra i flödet och hur allting kopplas samman.
        </p>

        <p>
            Med tanke på artikeln 'PHP The Right Way' är bland annat Composer och Autoloading viktiga delar som lyfts fram.
            Composer är en väldigt kraftfull pakethanterare som är mycket användbar vid hantering av beroenden.
            Den underlättaren även utvecklingen av applikationer i PHP.
            Autoloading gör att man på ett enklare ochh effektivare sätt kan utföra laddning av klassfiler utan manuell inkludering.
            Dessutom lyft vikten av att använda sig av objektorienterad programmering, som jag även under tidigare kurs förstått ger en möjlighet för att ha en strukturerad och lätt underhållbar kod.
            Det finns inte några särskilda områden som jag just nu känner att jag vill veta mer om.
        </p>

        <p>
            Min TIL för detta kmom är att jag har fått en bättre förståelse för hur jag kan koppla routes i PHP med twigfiler och på så sett visa något på en hemsida.
        </p>
    </div>

    <a href="{{ path('report') }}#kmom02">Kmom02</a>

    <div id="kmom02">
        <p>Här är min redovisningstext för kmom02</p>

        <p>
            Arv, engelska Inheritance, används när en klass tar över variabler och metoder från en annan klass.
            Klassen som ärver kallas oftast för barnklass och klassen den ärver ifrån kallas ofta förälderklass eller basklass.
            Genom arv kan kod återanvändas och därmed sker ingen upprepning utav liknande funktionalitet i flera klasser.
            I PHP implementeras arv med hjälp av 'extends'.
            <br>
            Komposition, engelska Composition, används när man kombinerar flera klasser till en ny klass.
            Detta görs genom att en klass tar emot andra objekt som en parameter i dess konstruktor.
            När det finns en svagare koppling kallas det aggregat.
            Komposition gör det möjligt att skapa specialiserade klasser ssom har specifika egenskaper och metoder som föräldrarklassen inte har.
            <br>
            Interface är en abstrakt samling av metoder som beskriver vad en klass kan göra, men den visar inte hur den gör det.
            Det ger alltså en definition av metoderna som finns i klassen utan implementationen.
            Detta öppnar upp möjligheten för att ändra implementationen utan att påverka Interface, det ger flexibilitet.
            <br>
            Trait är en funktion som gör det möjligt att återanvända kod mellan klasser, ett sätt att dela funktionalitet utan arv.
            I PHP implementeras trait med hjälp av 'trait' namnpåtrait och sedan koden.
            Trait inkluderas med hjälp av 'use' och den fungerar såsom om koden hade varit skriven direkt i klassen.
        </p>

        <p>
            Jag började med att implementera klasserna Card, CardHand, DeckOfCards och DeckOfCardsJoker.
            Card representerar ett kort och CardHand en korthand. Sedan valde jag att skapa DeckOfCardsJoker som ärvde från DeckOfCards och la till två jokrar i kortleken.
            Parallellt jobbade jag med att mina sidor och följde övningen och föreläsning för att få alla bitarna att fungera.
            Jag fastnade sedan länge på JSON API kraven, hade svårt att förstå vad som behövde göras, men efter ett förtydligande förstod jag hur jag skulle ta mig vidare.
            Hade även problem med POST, men förstod efter hjälp från läraren och påminnelse av övningen att jag kunde skapa knappar som länkade till routes.
            Här återanvände jag mycket av koden jag skapat i mina sidor.
            <br>
            Som helhet är jag nöjd med min kod, evnetuell en förbättrinspotential i uppdelandet av klasser.
            Eftersom det är väldigt mycket att hålla koll på, underlättar det om man har en bra struktur.
        </p>

        <p>
            Att förstå hur klasser hänger ihop och hur flödet i ens kod är hjälper till och underlättar både vid skapandet av koden, men även när man behöver debugga.
            Det stödjer definitivt i problemlösningsprocessen och hur man ska strukturera koden i en applikation.
        </p>

        <p>
            Min TIL för detta kmom är att jag lärde mig hur man kan skapa en knapp för att använda sig utav POST och på det sättet visa upp JSON strukturer i webbläsaren.
        </p>
    </div>

    <a href="{{ path('report') }}#kmom03">Kmom03</a>

    <div id="kmom03">
        <p>Här är min redovisningstext för kmom03</p>

        <p>
            Att modellera ett kortspel med flödesdiagram bidrog till att jag innan jag började programmera kunde ha en klarare bild av hur jag skulle bygga upp koden.
            Det hjälpte mig även att kunna se hela bilden, vilket var hjälpsamt.
            Pseudokoden bidrog till att jag kunde ha en grund för de mindre delarna av flödesdiagrammet och med hjälp av det programmera koden.
            Jag anser att det undderlättade för mig vid start av uppgiften, men jag borde ha gått tillbaka och kollat på de i stunder där jag fastnade.
        </p>

        <p>
            Jag använde mig av dem klasserna jag skapat i tidigare uppgift: Card, DeckOfCards.
            Sedan skapade jag en ny klass Score där jag beräknade poängen för spelaren/bankiren och även jämförde poängen mellan spelarna för att utse en vinnare.
            
            För detta kmom valde jag att skapa en ny controller som skulle innehålla alla routes för spelet, det vill säga för startsidan/landningssidan, dokumentationen,
            init för att initiera spelet och sessionerna, spela, dra kort, bankiren drar kort och avsluta spelet.
            Flödet var enligt följande: man klickar på en länk 'Starta spelet' som leder till routen init.
            Där initieras sessionerna, alla spelarna får två kort som läggs till i deras lista/hand. Även kortlekens storlek beräknas.
            Denna route renderar html.twig sidan play där själva spelplanen för spelaren och två knappar (draw/end) visas.
            När spelaren klickar på draw knappen går den till routen draw och där dras ett kort som läggs till i spelaren hand och visas på sidan, även kortlekens storlek ändras.
            Routen redirectar till routen play som bara renderar samma html.twig, samma sida.
            När spelaren klickar på end knappen, skickas den till routen bankir_draw där bankiren drar kort så länge dess poäng är under 17, sessionerna uppdateras och den redirectar till routen end.
            I routen end beräknas spelaren och bankirens totala poäng och jämförs med hjälp av metoder i klassen Score och en vinnare utses.
            I min play.html.twig har jag med hjälp av en if-sats gjort så att när det finns en vinnare visas vinnaren och bankirens hand och totala poäng.
        </p>

        <p>
            Jag fastnade väldigt länge på detta kmom och tyckte det var väldigt många steg som behövde göras, vilket kändes överväldigande.
            Med tanke på det så är jag nöjd att jag lyckades ta mig igenom uppgiften och kraven.
            Förbättringspotentialen jag ser just nu är att göra controllern ännu tunnare och bryta ut och placera i klasser.
            Självklart vore det också snyggare om man kunde rita ut korten ordentligt med hjälp av bild istället för i formatet [A♦] som jag har gjort.
        </p>

        <p>
            En så länge tycker jag att det fortfarande är lite svårt att koda i ramverket Symfony.
            Man måste hålla koll på strukturen en hel del med templates, src, controller m.m.
            När man har jobbat ett tag och kommit in i det bättre tror jag att det kan vara ett kraftigt verktyg att ha.
        </p>

        <p>
            Min TIL för detta kmom är att jag lärde mig lite mer om hur flödesdiagram kan hjälpa och underlätta för en i ett tidigt skede i programmering.
        </p>
    </div>

    <a href="{{ path('report') }}#kmom04">Kmom04</a>

    <div id="kmom04">
        <p>Här är min redovisningstext för kmom04</p>

        <p>
            Att skriva kod som testar annan kod har jag gjort i en tidigare kurs där jag jobbade med programmeringsspråket python.
            När jag gjorde det för första gången tyckte jag att det var svårt att komma in i tankesättet.
            Nu när jag provar på det för andra gången så känns det som att jag har kommit in i det mer och förstår syftet med enhetstestningar bättre.
            PHPUnit var helt okej att jobba med. Det fanns ett logiskt flöde i processen, såsom till exempel att testfilen för varje klass har samma namn som den ursprungliga klassen följt av ordet 'Test'.
            Det var även väldigt smidigt att använda sig av kommandot composer phpunit.
        </p>

        <p>
            Jag lyckades helt okej med kodtäckningen.
            I början tog jag en klass i taget och försökte skapa testfall som testade majoriteten av metoderna.
            Försökte även få in negativa utfall, men jag tyckte att det var lite svårare och gjorde det inte på alla klassers metoder.
        </p>

        <p>
            Min kod är till största delen testbar då många av mina metoder antingen handlar om att returnera en siffra, en valör, en poäng.
            Självklart finns det saker man kan göra för att förbättra kodens testbarhet, som att skala ner koden i metoderna då jag i bland har väldigt snarlika metoder.
            På grund av tidsbrist valde jag dock inte att skriva om dessa delar av koden för att förbättra den.
        </p>

        <p>
            Jag anser att kod som är testbar också kan indikera att koden är snygg och ren.
            När koden är välstrukturerad och skiljer olika delar åt så att det blir enkelt att hänga med i vad varje metod har för syfte kan man också testa den mycket enklare.
        </p>

        <p>
            Min TIL för detta kmom är att jag lärde mig mer om enhetstestning och jag lärde mig dokumentera min kod med PHPDoc.
        </p>
    </div>

    <a href="{{ path('report') }}#kmom05">Kmom05</a>

    <div id="kmom05">
        <p>Här är min redovisningstext för kmom05</p>

        <p>
            Det gick jättebra att jobba igenom övningen med Symfony och Doctrine.
            Dokumentet var kort och konsist, vilket gjorde det lätt att hänga med i.
            När jag fastnade öppnade jag Mikaels videogenomgångar och kunde sedan jobba vidare.
            Övningen och uppbyggnaden påmminde mig om vad jag gjort i tidigare kmom. Den hade ett logiskt flöde.
        </p>

        <p>
            Jag grundade min applikation i övningen, den var basen.
            Vid landningssidan skapade jag två länkar i botten, en för att skapa en bok i biblioteket och en för att se samtliga böcker.
            När man klickade på att skapa en bok kom man till ett formulär där man kunde fylla i information.
            När man klickade på att se samtliga böcker kom man till en sida som med länkar visade böckerna.
            Klickade man på länken hamnade man på en sida där man kunde se var bok för sig och dess information.
            I vyn där samtliga böcker syntes fanns två knappar, en för att uppdatera och en för att radera boken.
            Uppdatera använde sig av ett liknande formulär som skapa böcker använde sig av.
        </p>

        <p>
            Det var nytt att jobba med ORM i CRUD och därmed också krångligt till en början.
            Många av CRUD-operationerna var färdiga metoder och funktioner vilket gjorde det enkelt att jobba med.
            ORM i jämförelse med att direkt jobba med SQL-query som vi gjort i tidigare kurser har bland annat följande skillnader:
            ORM är mer läsbar eftersom man kan använda sig av objekt och metoder för att skriva komplexa SQL-förfrågningar,
            ORM har inbyggda metoder för att man ska hämta och manipulera data.
        </p>

        <p>
            Min uppfattning om ORM såhär långt är att det är ett effektivt verktyg som underlättar hanteringen av interaktioner med databaser.
            Den bidrar till minskat skrivande av direkt SQL-kod. Detta gör därmed att koden som skrivs blir mer objektorienterad.
        </p>

        <p>
            Min TIL för detta kmom är att jag lärde mig om ORM som ramverk och hur man kan integrera det med databasen. 
        </p>
    </div>

    <a href="{{ path('report') }}#kmom06">Kmom06</a>

    <div id="kmom06">
        <p>Här är min redovisningstext för kmom06</p>

        <p>
            Jag tyckte att phpmetrics verktyget var väldigt användbart.
            Det var väldigt smidigt att man kunde kolla upp nästan alla sex C:na i sidbaren till vänster.
            Jag uppskattade både metrics som visade complexity, men även dem som visade violations och error.
        </p>

        <p>
            Min första känsla av Scrutinizer och dess badges är att det hjälper en snabbt att få en överblick över kodkvalitet, build och coverage.
            Efter första bygget fick jag en kodtäckning på 16%, inte så högt men ändå helt okej med tanke på att jag inte gjort enhetstester till klasserna som var controllers.
            Kodkvaliteten var 9.96, ett väldigt bra värde.
            Trots det uppfattade jag phpmetrics som mer lätttolkad i vissa aspekter vad gäller vad man kan förbättra och hur.
        </p>

        <p>
            Kodkvalitet kan definitivt i någon mån visas med badges.
            De sex C:na visar tydligt på att det finns vissa strukturella aspekter/riktlinjer som man kan mäta sin kod mot.
            Sedan kanske inte bra kod enbart behöver definieras av dessa, eftersom det är många delar som spelar in.
            Ett exempel som jag själv tänker på är en förändring jag gjorde i min LibraryController där jag delade upp den i mindre delar.
            Jag förstår dels tankesättet att förenkla, men samtidigt i just det sammanhanget hade alla routes en koppling till library och, enligt mig, var det inte fel att de låg i samma klass.
        </p>

        <p>
            Min TIL för detta kmom är att jag lärde mig använda phpmetrics och Scrutinizer.
            Jag lärde mig värdet av clean-code med hjälp av de sex C:na och hur det kan påverka kodkvalitet.
        </p>
    </div>

    <a href="{{ path('report') }}#kmom10">Kmom10</a>

    <div id="kmom10">
        <p>Här är min redovisningstext för kmom10</p>

        <p>
            Krav 1-3: Innehåll och utseende
            <br>
            Jag började med att skapa en kontroller ProjectControllerTwig där jag skapade en klass med samma namn och inuti den placerade jag sedan alla routes.
            Sedan i templates/ skapade jag mappen project och inuti den placerade jag about/finished/home/play.html.twig.
            Jag la sedan till en landingssida genom att skapa en route i min kontroller som renderade home.html.twig.
            På den sidan visade jag en länk som ledde till about.html.twig sidan där jag skrev lite kort om projektet.
            Sedan hade jag även ett formulär där man kunde skriva in namn och antal händer.
            Under detta fanns en knapp som ledde till att spelet startades.
            Hela spelet fanns på play.html.twig som byggdes om dynamiskt beroende på vad spelaren klickade på.
            För att åstadkomma de olika funktionaliteterna skapade jag routen project_init som initierade kortleken, gav alla spelarna och bankiren två kort, beräkna varderas poäng och la ended_handX variabeln till false.
            Hämtade även antalet händer och namnet personen skrev in i formuläret.
            Beroende på om spelaren valde att klicka på Draw eller End knappen kom den in i olika routes som gjorde olika saker.
            Draw knappen ledde till routen project_draw. Där fick spelaren dra ett kort som las till i dess hand om det fanns kort kvar i högen.
            Jag kontrollerade även att ended_handX variabeln var false, alltså att spelaren inte avslutat spelet.
            Poängen beräknades och sedan uppdaterades sessionerna.
            End knappen ledde till routen project_end. Där beräknades spelarens poäng och sparades undan i session och även dess hand togs bort så att den inte längre hade möjlighet att fortsätta spela.
            Här skapade jag även en kontroller som kollade om det fanns en value som var false innebar det att det fanns spelare kvar som ville spela. Då renderade jag project/play.html.twig igen, annars redirecta jag till routen project_finished.
            I den routen drog bankiren dess kort, dennes poäng beräknades och med hjälp av projectCompareHands() i Score.php utsågs en vinnare.
            Routen renderade sedan finish.html.twig som skrev ut vem vinnaren var.
            <br>
            Valde sedan att göra om min style som jag redan hade och gjorde den lite mer färgglad med en uppdaterad header och footer.
            <br><br>
            Krav 1-3: Repo och dokumentation
            <br>
            Jag uppdaterade min README.md med information och nya Scrutinizer badges.
            Sedan körde jag om samtliga kommandon: composer csfix, composer lint, composer phpunit, composer phpdoc, composer phpmetrics.
        </p>

        <p>
            Jag tyckte att detta var ett av de svåra slutprojekten.
            Jag hade mycket problem med att få sessionerna att fungera.
            Det verkade inte som att jag sparade undan värdena på ett korrekt sätt, vilket bidrog till exempel till att det aldrig gick över till nästa spelares tur och att spelaren som dragit ett kort inte fick det tillagt i sin hand.
            Detta var alltså ett projekt som tog lång tid.
            Trots att vi fick det förenklat, eftersom vi jobbade på ett kmom i två veckor, tyckte jag att det var svårt.
        </p>

        <p>
            Kursen var helt okej. Återigen befäste jag kunskaper jag introducerats till i tidigare kurser.
            Förstod ännu en gång databaser och enhetstester bättre.
            De föreläsningarna som var förinspelade, valde jag, på grund av tidsbrist, att inte kolla på och följde därför bara med på föreläsningarna samt läste materialet/artiklarna till varje kmom.
            Eventuellt att föreläsningarna skulle kunna finnas till som extramaterial då jag kände att föreläsningarna täckte det mesta.
            Jag är nöjd med kursen, men är osäker på om jag skulle rekommendera den vidare då den har väldigt hög arbetsbelastning.
            Slutligen ger jag den en sexa.
        </p>

    </div>
{% endblock %}